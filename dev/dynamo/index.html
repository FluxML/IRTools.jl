<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Dynamo · IRTools</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">IRTools</span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li class="is-active"><a class="tocitem" href>Dynamo</a><ul class="internal"><li><a class="tocitem" href="#A-Simple-Dynamo-1"><span>A Simple Dynamo</span></a></li><li><a class="tocitem" href="#Recursing-1"><span>Recursing</span></a></li><li><a class="tocitem" href="#Using-Dispatch-1"><span>Using Dispatch</span></a></li><li><a class="tocitem" href="#Contexts-1"><span>Contexts</span></a></li></ul></li><li><a class="tocitem" href="../reference/">Reference</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Dynamo</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Dynamo</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/MikeInnes/IRTools.jl/blob/master/docs/src/dynamo.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Dynamo-1"><a class="docs-heading-anchor" href="#Dynamo-1">Dynamo</a><a class="docs-heading-anchor-permalink" href="#Dynamo-1" title="Permalink"></a></h1><p>IRTools can be used with metaprogramming tools like <a href="https://github.com/jrevels/Cassette.jl">Cassette</a>, but it also provides a few of its own utilities. The main one is named the &quot;dynamo&quot; after the idea of a &quot;dynamically-scoped macro&quot;.</p><p>Let me explain. If you write down</p><pre><code class="language-julia">@foo begin
  bar(baz())
end</code></pre><p>then the <code>@foo</code> macro has access to the expression <code>bar(baz())</code> and can modify this however it pleases. However, the code of the functions <code>bar</code> and <code>baz</code> are completely invisible; in more technical terms the macro has lexical extent.</p><p>In contrast, a dynamo looks like this:</p><pre><code class="language-julia">foo() do
  bar(baz())
end</code></pre><p>This can <em>also</em> freely modify the <code>bar(baz())</code> expression (though it sees it as an <code>IR</code> object rather than <code>Expr</code>). But more importantly, it can <em>recurse</em>, viewing and manipulating the source code of <code>bar</code> and <code>baz</code> and even any functions <em>they</em> call. In other words, it has dynamic extent.</p><p>For example, imagine a macro for replacing <code>*</code> with <code>+</code>:</p><pre><code class="language-julia">julia&gt; using MacroTools

julia&gt; macro foo(ex)
         MacroTools.prewalk(ex) do x
           x == :* ? :+ : x
         end |&gt; esc
       end
@foo (macro with 1 method)

julia&gt; @foo 10*5
15

julia&gt; @foo prod([5, 10])
50</code></pre><p>The explicit <code>*</code> that appears to the macro gets changed, but the implicit one inside <code>prod</code> does not. This guide shows you how to do one better.</p><h2 id="A-Simple-Dynamo-1"><a class="docs-heading-anchor" href="#A-Simple-Dynamo-1">A Simple Dynamo</a><a class="docs-heading-anchor-permalink" href="#A-Simple-Dynamo-1" title="Permalink"></a></h2><p>The simplest possible dynamo is a no-op, analagous to the macro</p><pre><code class="language-julia">macro roundtrip(ex)
  esc(ex)
end</code></pre><p>Here it is:</p><pre><code class="language-julia-repl">julia&gt; using IRTools: IR, @dynamo

julia&gt; @dynamo roundtrip(a...) = IR(a...)

julia&gt; mul(a, b) = a*b
mul (generic function with 1 method)

julia&gt; roundtrip(mul, 2, 3)
6</code></pre><p>Here&#39;s how it works: our dynamo gets passed a set of <em>argument types</em> <code>a...</code>. We can use this to get IR for the method being called, with <code>IR(a...)</code>. Then we can transform that IR, return it, and it&#39;ll be compiled and run as usual.</p><p>In this case, we can easily check that the transformed code produced by <code>roundtrip</code> is identical to the original IR for <code>mul</code>.</p><pre><code class="language-julia-repl">julia&gt; using IRTools: @code_ir

julia&gt; @code_ir mul(2, 3)
1: (%1, %2, %3)
  %4 = %2 * %3
  return %4

julia&gt; @code_ir roundtrip mul(1, 2)
1: (%1, %2, %3)
  %4 = %2 * %3
  return %4</code></pre><p>Now we can recreate our <code>foo</code> macro. It&#39;s a little more verbose since simple symbols like <code>*</code> are resolved to <code>GlobalRef</code>s in lowered code, but it&#39;s broadly the same as our macro.</p><pre><code class="language-julia-repl">julia&gt; using MacroTools

julia&gt; @dynamo function foo(a...)
         ir = IR(a...)
         ir = MacroTools.prewalk(ir) do x
           x isa GlobalRef &amp;&amp; x.name == :(*) &amp;&amp; return GlobalRef(Base, :+)
           return x
         end
         return ir
       end</code></pre><p>It behaves identically, too.</p><pre><code class="language-julia-repl">julia&gt; foo() do
         10*5
       end
15

julia&gt; foo() do
         prod([10, 5])
       end
50</code></pre><p>To get different behaviour we need to <em>go deeper</em> – and talk about recursion.</p><h2 id="Recursing-1"><a class="docs-heading-anchor" href="#Recursing-1">Recursing</a><a class="docs-heading-anchor-permalink" href="#Recursing-1" title="Permalink"></a></h2><p>A key difference between macros and dynamos is that dynamos get passed <em>functions</em> with they look inside, rather than expressions, so we don&#39;t need to write out <code>mul</code> when calling <code>foo(mul, 5, 10)</code>.</p><p>So what if <code>foo</code> actually inserted calls to itself when modifying a function? In other words, <code>prod([1, 2, 3])</code> would become <code>foo(prod, [1, 2, 3])</code>, and so on for each call inside a function. This lets us get the &quot;dynamic extent&quot; property that we talked about earlier.</p><pre><code class="language-julia-repl">julia&gt; using IRTools: xcall

julia&gt; @dynamo function foo2(a...)
         ir = IR(a...)
         ir == nothing &amp;&amp; return
         ir = MacroTools.prewalk(ir) do x
           x isa GlobalRef &amp;&amp; x.name == :(*) &amp;&amp; return GlobalRef(Base, :+)
           return x
         end
         for (x, st) in ir
           isexpr(st.expr, :call) || continue
           ir[x] = xcall(foo2, st.expr.args...)
         end
         return ir
       end</code></pre><p>There are two changes here: firstly, walking over all IR statements to look for, and modify, <code>call</code> expressions. Secondly we handle the case where <code>ir == nothing</code>, which can happen when we hit things like intrinsic functions for which there is no source code. If we return <code>nothing</code>, the dynamo will just run that function as usual.</p><p>Check it does the transform we wanted:</p><pre><code class="language-julia">julia&gt; mul_wrapped(a, b) = mul(a, b)
mul_wrapped (generic function with 1 method)

julia&gt; @code_ir mul_wrapped(5, 10)
1: (%1, %2, %3)
  %4 = mul(%2, %3)
  return %4

julia&gt; @code_ir foo2 mul_wrapped(5, 10)
1: (%1, %2, %3)
  %4 = (foo2)(mul, %2, %3)
  return %4</code></pre><p>And that it works as expected:</p><pre><code class="language-julia-repl">julia&gt; foo() do # Does not work (since there is no literal `*` here)
         mul(5, 10)
       end
50

julia&gt; foo2() do # Works correctly
         mul(5, 10)
       end
15

julia&gt; foo2() do
         prod([5, 10])
       end
15</code></pre><p>This, we have rewritten the <code>prod</code> function to actually calculate <code>sum</code>, by <em>internally</em> rewriting all calls to <code>*</code> to instead use <code>+</code>.</p><h2 id="Using-Dispatch-1"><a class="docs-heading-anchor" href="#Using-Dispatch-1">Using Dispatch</a><a class="docs-heading-anchor-permalink" href="#Using-Dispatch-1" title="Permalink"></a></h2><p>We can make our <code>foo2</code> dynamo simpler in a couple of ways. Firstly, IRTools provides a built-in utility <code>recurse!</code> which makes it easy to recurse into code.</p><pre><code class="language-julia-repl">julia&gt; using IRTools: recurse!

julia&gt; @dynamo function foo2(a...)
         ir = IR(a...)
         ir == nothing &amp;&amp; return
         ir = MacroTools.prewalk(ir) do x
           x isa GlobalRef &amp;&amp; x.name == :(*) &amp;&amp; return GlobalRef(Base, :+)
           return x
         end
         recurse!(ir)
         return ir
       end

julia&gt; foo2() do
         prod([5, 10])
       end
15</code></pre><p>Secondly, unlike in a macro, we don&#39;t actually need to look through source code for literal references to the <code>*</code> function. Because our dynamo is a normal function, we can actually use dispatch to decide what specific functions should do.</p><pre><code class="language-julia-repl">julia&gt; foo3(::typeof(*), a, b) = a+b
foo3 (generic function with 1 method)

julia&gt; foo3(*, 5, 10)
15</code></pre><p>Now we can define a simpler version of <code>foo3</code> which <em>only</em> recurses, and let dispatch figure out when to turn <code>*</code>s into <code>+</code>s.</p><pre><code class="language-julia-repl">julia&gt; @dynamo function foo3(a...)
         ir = IR(a...)
         ir == nothing &amp;&amp; return
         recurse!(ir)
         return ir
       end

julia&gt; foo3() do
         prod([5, 10])
       end
15</code></pre><h2 id="Contexts-1"><a class="docs-heading-anchor" href="#Contexts-1">Contexts</a><a class="docs-heading-anchor-permalink" href="#Contexts-1" title="Permalink"></a></h2><p>We can achieve some interesting things by making our dynamo a <em>closure</em>, i.e. a callable object capable of holding some state. For example, consider an object which simply records a count.</p><pre><code class="language-julia-repl">julia&gt; mutable struct Counter
         count::Int
       end

julia&gt; Counter() = Counter(0)
Counter

julia&gt; count!(c::Counter) = (c.count += 1)
count! (generic function with 1 method)</code></pre><p>We can turn this into a dynamo which inserts a single statement into the IR of each function, to increase the count by one.</p><pre><code class="language-julia-repl">julia&gt; using IRTools: @dynamo, IR, xcall, self, recurse!

julia&gt; @dynamo function (c::Counter)(m...)
         ir = IR(m...)
         ir == nothing &amp;&amp; return
         recurse!(ir)
         pushfirst!(ir, xcall(count!, self))
         return ir
       end</code></pre><p>Now we can count how many function calls that happen in a given block of code.</p><pre><code class="language-julia-repl">julia&gt; c = Counter()
Counter(0)

julia&gt; c() do
         1 + 2.0
       end
3.0

julia&gt; c.count
18</code></pre><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>On Julia versions older than 1.3, dynamos are <em>not</em> automatically updated when you redefine functions. For example:</p><pre><code class="language-julia">julia&gt; @dynamo roundtrip(a...) = IR(a...)

julia&gt; foo(x) = x^2
foo (generic function with 1 method)

julia&gt; roundtrip(foo, 5)
25

julia&gt; foo(x) = x+1
foo (generic function with 1 method)

julia&gt; roundtrip(foo, 5)
25</code></pre><p>In order to get the dynamo to see the new definition of <code>foo</code>, you can explicitly call <code>IRTools.refresh()</code>:</p><pre><code class="language-julia">julia&gt; IRTools.refresh(roundtrip)

julia&gt; roundtrip(foo, 5)
6</code></pre><p>With Julia 1.3 and later, <code>IRTools.refresh</code> is not required. </p></div></div></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« Home</a><a class="docs-footer-nextpage" href="../reference/">Reference »</a></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Tuesday 16 June 2020 13:38">Tuesday 16 June 2020</span>. Using Julia version 1.0.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
